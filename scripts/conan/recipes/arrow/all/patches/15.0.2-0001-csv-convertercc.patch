diff --git a/cpp/src/arrow/csv/converter.cc b/cpp/src/arrow/csv/converter.cc
index 3825364fa..3969ae8ce 100644
--- a/cpp/src/arrow/csv/converter.cc
+++ b/cpp/src/arrow/csv/converter.cc
@@ -28,6 +28,7 @@
 #include "arrow/array/builder_binary.h"
 #include "arrow/array/builder_decimal.h"
 #include "arrow/array/builder_dict.h"
+#include "arrow/array/builder_nested.h"
 #include "arrow/array/builder_primitive.h"
 #include "arrow/csv/parser.h"
 #include "arrow/status.h"
@@ -113,7 +114,7 @@ struct ValueDecoder {
                         const ConvertOptions& options)
       : type_(type), options_(options) {}
 
-  Status Initialize() {
+  virtual Status Initialize() {
     // TODO no need to build a separate Trie for each instance
     return InitializeTrie(options_.null_values, &null_trie_);
   }
@@ -236,7 +237,7 @@ struct BooleanValueDecoder : public ValueDecoder {
 
   using ValueDecoder::ValueDecoder;
 
-  Status Initialize() {
+  Status Initialize() override {
     // TODO no need to build separate Tries for each instance
     RETURN_NOT_OK(InitializeTrie(options_.true_values, &true_trie_));
     RETURN_NOT_OK(InitializeTrie(options_.false_values, &false_trie_));
@@ -483,6 +484,16 @@ class ConcreteDictionaryConverter : public DictionaryConverter {
   using DictionaryConverter::DictionaryConverter;
 };
 
+class ConcreteListConverter : public ListConverter {
+ public:
+  using ListConverter::ListConverter;
+};
+
+class ConcreteMapConverter : public MapConverter {
+ public:
+  using MapConverter::MapConverter;
+};
+
 //
 // Concrete Converter for nulls
 //
@@ -608,6 +619,306 @@ class TypedDictionaryConverter : public ConcreteDictionaryConverter {
   int32_t max_cardinality_ = std::numeric_limits<int32_t>::max();
 };
 
+//
+// Concrete Converter factory for lists
+//
+
+template <typename T, typename ValueDecoderType>
+class TypedListConverter : public ConcreteListConverter {
+ public:
+  TypedListConverter(const std::shared_ptr<DataType>& value_type,
+                     const ConvertOptions& options, MemoryPool* pool)
+      : ConcreteListConverter(value_type, options, pool),
+        decoder_(value_type, options_) {}
+
+  Result<std::shared_ptr<Array>> Convert(const BlockParser& parser,
+                                         int32_t col_index) override {
+    using BuilderType = typename TypeTraits<T>::BuilderType;
+    using value_type = typename ValueDecoderType::value_type;
+
+    auto list_separator = parser.getParseOptions().collection_delimiter;
+
+    auto value_builder = std::make_shared<BuilderType>(value_type_, pool_);
+    arrow::ListBuilder list_builder(pool_, value_builder);
+
+    auto visit = [&](const uint8_t* data, uint32_t size, bool quoted) -> Status {
+      if (decoder_.IsNull(data, size, quoted /* quoted */)) {
+        return list_builder.AppendNull();
+      }
+      if (ARROW_PREDICT_FALSE(list_builder.maximum_elements() > max_cardinality_)) {
+        return Status::IndexError("List length exceeded max cardinality");
+      }
+      ARROW_RETURN_NOT_OK(list_builder.Append());
+      std::string str((char*)data, size);
+      std::stringstream ss(str);
+      std::string token;
+      while (std::getline(ss, token, list_separator)) {
+        if (decoder_.IsNull((uint8_t*)token.c_str(), token.size(), quoted /* quoted */)) {
+          ARROW_RETURN_NOT_OK(value_builder->AppendNull());
+          continue;
+        }
+
+        value_type value{};
+        ARROW_RETURN_NOT_OK(
+            decoder_.Decode((uint8_t*)token.c_str(), token.size(), quoted, &value));
+        ARROW_RETURN_NOT_OK(value_builder->Append(value));
+      }
+      return Status::OK();
+    };
+    ARROW_RETURN_NOT_OK(parser.VisitColumn(col_index, visit));
+
+    std::shared_ptr<Array> res;
+    ARROW_RETURN_NOT_OK(list_builder.Finish(&res));
+    return res;
+  }
+
+  void SetMaxCardinality(int32_t max_length) override { max_cardinality_ = max_length; }
+
+ protected:
+  Status Initialize() override {
+    util::InitializeUTF8();
+    return decoder_.Initialize();
+  }
+
+  ValueDecoderType decoder_;
+  int32_t max_cardinality_ = std::numeric_limits<int32_t>::max();
+};
+
+template <typename BuilderType, typename DecoderType>
+arrow::Status appendTypedValue(std::shared_ptr<ValueDecoder> decoder,
+                               std::shared_ptr<ArrayBuilder> builder, const uint8_t* data,
+                               uint32_t size, bool quoted) {
+  using value_type = typename DecoderType::value_type;
+  value_type value{};
+  auto concretedDecoder = std::static_pointer_cast<DecoderType>(decoder);
+  ARROW_RETURN_NOT_OK(concretedDecoder->Decode(data, size, quoted, &value));
+  auto concreteBuilder = std::dynamic_pointer_cast<BuilderType>(builder);
+  ARROW_RETURN_NOT_OK(concreteBuilder->Append(value));
+  return Status::OK();
+}
+
+arrow::Status appendValue(std::shared_ptr<DataType> type,
+                          std::shared_ptr<ValueDecoder> decoder,
+                          std::shared_ptr<ArrayBuilder> builder, const uint8_t* data,
+                          uint32_t size, bool quoted, const ConvertOptions options) {
+  switch (type->id()) {
+    case Type::BOOL:
+      return appendTypedValue<BooleanBuilder, BooleanValueDecoder>(decoder, builder, data,
+                                                                   size, quoted);
+    case Type::INT8:
+      return appendTypedValue<Int8Builder, NumericValueDecoder<Int8Type>>(
+          decoder, builder, data, size, quoted);
+    case Type::INT16:
+      return appendTypedValue<Int16Builder, NumericValueDecoder<Int16Type>>(
+          decoder, builder, data, size, quoted);
+    case Type::INT32:
+      return appendTypedValue<Int32Builder, NumericValueDecoder<Int32Type>>(
+          decoder, builder, data, size, quoted);
+    case Type::INT64:
+      return appendTypedValue<Int64Builder, NumericValueDecoder<Int64Type>>(
+          decoder, builder, data, size, quoted);
+    case Type::FLOAT:
+      return appendTypedValue<FloatBuilder, NumericValueDecoder<FloatType>>(
+          decoder, builder, data, size, quoted);
+    case Type::DOUBLE:
+      return appendTypedValue<DoubleBuilder, NumericValueDecoder<DoubleType>>(
+          decoder, builder, data, size, quoted);
+    case Type::DECIMAL:
+      return appendTypedValue<DecimalBuilder, DecimalValueDecoder>(decoder, builder, data,
+                                                                   size, quoted);
+    case Type::TIMESTAMP:
+      return appendTypedValue<TimestampBuilder, InlineISO8601ValueDecoder>(
+          decoder, builder, data, size, quoted);
+    case Type::FIXED_SIZE_BINARY:
+      return appendTypedValue<FixedSizeBinaryBuilder, FixedSizeBinaryValueDecoder>(
+          decoder, builder, data, size, quoted);
+    case Type::BINARY:
+      return appendTypedValue<BinaryBuilder, BinaryValueDecoder<false>>(
+          decoder, builder, data, size, quoted);
+    case Type::LARGE_BINARY:
+      return appendTypedValue<LargeBinaryBuilder, BinaryValueDecoder<false>>(
+          decoder, builder, data, size, quoted);
+    case Type::STRING:
+      if (options.check_utf8) {
+        return appendTypedValue<StringBuilder, BinaryValueDecoder<true>>(
+            decoder, builder, data, size, quoted);
+      } else {
+        return appendTypedValue<StringBuilder, BinaryValueDecoder<false>>(
+            decoder, builder, data, size, quoted);
+      }
+    case Type::LARGE_STRING:
+      if (options.check_utf8) {
+        return appendTypedValue<LargeStringBuilder, BinaryValueDecoder<true>>(
+            decoder, builder, data, size, quoted);
+      } else {
+        return appendTypedValue<LargeStringBuilder, BinaryValueDecoder<false>>(
+            decoder, builder, data, size, quoted);
+      }
+      break;
+    default:
+      return Status::NotImplemented("Type is not implemented");
+  }
+}
+
+std::shared_ptr<ArrayBuilder> getBuilder(const std::shared_ptr<DataType>& type,
+                                         MemoryPool* pool) {
+  switch (type->id()) {
+    case Type::BOOL:
+      return std::make_shared<BooleanBuilder>(type, pool);
+    case Type::INT8:
+      return std::make_shared<Int8Builder>(type, pool);
+    case Type::INT16:
+      return std::make_shared<Int16Builder>(type, pool);
+    case Type::INT32:
+      return std::make_shared<Int32Builder>(type, pool);
+    case Type::INT64:
+      return std::make_shared<Int64Builder>(type, pool);
+    case Type::FLOAT:
+      return std::make_shared<FloatBuilder>(type, pool);
+    case Type::DOUBLE:
+      return std::make_shared<DoubleBuilder>(type, pool);
+    case Type::DECIMAL:
+      return std::make_shared<Decimal128Builder>(type, pool);
+    case Type::TIMESTAMP:
+      return std::make_shared<TimestampBuilder>(type, pool);
+    case Type::FIXED_SIZE_BINARY:
+      return std::make_shared<FixedSizeBinaryBuilder>(type, pool);
+    case Type::BINARY:
+      return std::make_shared<BinaryBuilder>(type, pool);
+    case Type::LARGE_BINARY:
+      return std::make_shared<LargeBinaryBuilder>(type, pool);
+    case Type::STRING:
+      return std::make_shared<StringBuilder>(type, pool);
+    case Type::LARGE_STRING:
+      return std::make_shared<LargeStringBuilder>(type, pool);
+    default:
+      throw std::runtime_error("Not implemented builder for type");
+  }
+}
+
+std::shared_ptr<ValueDecoder> getDecoder(const std::shared_ptr<DataType>& type,
+                                         const ConvertOptions& options) {
+  switch (type->id()) {
+    case Type::BOOL:
+      return std::make_shared<BooleanValueDecoder>(type, options);
+    case Type::INT8:
+      return std::make_shared<NumericValueDecoder<Int8Type>>(type, options);
+    case Type::INT16:
+      return std::make_shared<NumericValueDecoder<Int16Type>>(type, options);
+    case Type::INT32:
+      return std::make_shared<NumericValueDecoder<Int32Type>>(type, options);
+    case Type::INT64:
+      return std::make_shared<NumericValueDecoder<Int64Type>>(type, options);
+    case Type::FLOAT:
+      return std::make_shared<NumericValueDecoder<FloatType>>(type, options);
+    case Type::DOUBLE:
+      return std::make_shared<NumericValueDecoder<DoubleType>>(type, options);
+    case Type::DECIMAL: {
+      if (options.decimal_point != '.') {
+        throw std::runtime_error("Custom decimal value separator is not supported");
+      }
+      return std::make_shared<DecimalValueDecoder>(type, options);
+    }
+    case Type::TIMESTAMP:
+      return std::make_shared<InlineISO8601ValueDecoder>(type, options);
+    case Type::FIXED_SIZE_BINARY:
+      return std::make_shared<FixedSizeBinaryValueDecoder>(type, options);
+    case Type::BINARY:
+      return std::make_shared<BinaryValueDecoder<false>>(type, options);
+    case Type::LARGE_BINARY:
+      return std::make_shared<BinaryValueDecoder<false>>(type, options);
+    case Type::STRING:
+    case Type::LARGE_STRING:
+
+      if (options.check_utf8) {
+        return std::make_shared<BinaryValueDecoder<true>>(type, options);
+      } else {
+        return std::make_shared<BinaryValueDecoder<false>>(type, options);
+      }
+    default:
+      throw std::runtime_error("Not implemented decoder for type");
+  }
+}
+
+//
+// Concrete Converter factory for lists
+//
+
+class TypedMapConverter : public ConcreteMapConverter {
+ public:
+  TypedMapConverter(const std::shared_ptr<DataType>& key_type,
+                    const std::shared_ptr<DataType>& item_type_,
+                    const ConvertOptions& options, MemoryPool* pool)
+      : ConcreteMapConverter(key_type, item_type_, options, pool),
+        key_decoder_(getDecoder(key_type, options_)),
+        item_decoder_(getDecoder(item_type_, options_)) {}
+
+  Result<std::shared_ptr<Array>> Convert(const BlockParser& parser,
+                                         int32_t col_index) override {
+    auto key_builder = getBuilder(key_type_, pool_);
+    auto item_builder = getBuilder(item_type_, pool_);
+
+    MapBuilder map_builder(pool_, key_builder, item_builder);
+
+    auto parseOptions = parser.getParseOptions();
+    auto map_delimiter = parseOptions.map_key_delimiter;
+    auto list_delimiter = parseOptions.collection_delimiter;
+
+    auto visit = [&](const uint8_t* data, uint32_t size, bool quoted) -> Status {
+      if (key_decoder_->IsNull(data, size, quoted /* quoted */)) {
+        return map_builder.AppendNull();
+      }
+
+      ARROW_RETURN_NOT_OK(map_builder.Append());
+      std::string str((char*)data, size);
+      std::stringstream ss(str);
+      std::string token;
+      while (std::getline(ss, token, list_delimiter)) {
+        if (key_decoder_->IsNull((uint8_t*)token.c_str(), token.size(),
+                                 quoted /* quoted */)) {
+          ARROW_RETURN_NOT_OK(item_builder->AppendNull());
+          continue;
+        }
+
+        auto delimiterLocation = token.find(map_delimiter);
+        if (delimiterLocation == std::string::npos) {
+          return Status::Invalid("Map is not valid");
+        }
+
+        auto key = token.substr(0, delimiterLocation);
+        auto value = token.substr(delimiterLocation + 1);
+
+        ARROW_RETURN_NOT_OK(appendValue(key_type_, key_decoder_, key_builder,
+                                        (const uint8_t*)key.data(), key.size(), quoted,
+                                        options_));
+        ARROW_RETURN_NOT_OK(appendValue(item_type_, item_decoder_, item_builder,
+                                        (const uint8_t*)value.data(), value.size(),
+                                        quoted, options_));
+      }
+      return Status::OK();
+    };
+    ARROW_RETURN_NOT_OK(parser.VisitColumn(col_index, visit));
+
+    std::shared_ptr<Array> res;
+    ARROW_RETURN_NOT_OK(map_builder.Finish(&res));
+    ARROW_RETURN_NOT_OK(res->ValidateFull());
+    return res;
+  }
+
+  void SetMaxCardinality(int32_t max_length) override { max_cardinality_ = max_length; }
+
+ protected:
+  Status Initialize() override {
+    util::InitializeUTF8();
+    ARROW_RETURN_NOT_OK(key_decoder_->Initialize());
+    return item_decoder_->Initialize();
+  }
+
+  std::shared_ptr<ValueDecoder> key_decoder_;
+  std::shared_ptr<ValueDecoder> item_decoder_;
+  int32_t max_cardinality_ = std::numeric_limits<int32_t>::max();
+};
+
 //
 // Concrete Converter factory for timestamps
 //
@@ -665,6 +976,17 @@ DictionaryConverter::DictionaryConverter(const std::shared_ptr<DataType>& value_
     : Converter(dictionary(int32(), value_type), options, pool),
       value_type_(value_type) {}
 
+ListConverter::ListConverter(const std::shared_ptr<DataType>& value_type,
+                             const ConvertOptions& options, MemoryPool* pool)
+    : Converter(list(value_type), options, pool), value_type_(value_type) {}
+
+MapConverter::MapConverter(const std::shared_ptr<DataType>& key_type,
+                           const std::shared_ptr<DataType>& item_type_,
+                           const ConvertOptions& options, MemoryPool* pool)
+    : Converter(map(key_type, item_type_), options, pool),
+      key_type_(key_type),
+      item_type_(item_type_) {}
+
 Result<std::shared_ptr<Converter>> Converter::Make(const std::shared_ptr<DataType>& type,
                                                    const ConvertOptions& options,
                                                    MemoryPool* pool) {
@@ -747,6 +1069,24 @@ Result<std::shared_ptr<Converter>> Converter::Make(const std::shared_ptr<DataTyp
       return DictionaryConverter::Make(dict_type.value_type(), options, pool);
     }
 
+    case Type::LIST: {
+      try {
+        const auto& list_type = checked_cast<const ListType&>(*type);
+        return ListConverter::Make(list_type.value_type(), options, pool);
+      } catch (const std::exception& e) {
+        return Status::Invalid("Not supported LIST type is provided.", e.what());
+      }
+    }
+
+    case Type::MAP: {
+      try {
+        const auto& map_type = checked_cast<const MapType&>(*type);
+        return MapConverter::Make(map_type.key_type(), map_type.item_type(), options,
+                                  pool);
+      } catch (const std::exception& e) {
+        return Status::Invalid("Not supported MAP type is provided.", e.what());
+      }
+    }
     default: {
       return Status::NotImplemented("CSV conversion to ", type->ToString(),
                                     " is not supported");
@@ -827,5 +1167,77 @@ Result<std::shared_ptr<DictionaryConverter>> DictionaryConverter::Make(
   return ptr;
 }
 
+Result<std::shared_ptr<MapConverter>> MapConverter::Make(
+    const std::shared_ptr<DataType>& key_type, const std::shared_ptr<DataType>& item_type,
+    const ConvertOptions& options, MemoryPool* pool) {
+  std::shared_ptr<MapConverter> ptr;
+  ptr.reset(new TypedMapConverter(key_type, item_type, options, pool));
+  RETURN_NOT_OK(ptr->Initialize());
+  return ptr;
+}
+
+Result<std::shared_ptr<ListConverter>> ListConverter::Make(
+    const std::shared_ptr<DataType>& type, const ConvertOptions& options,
+    MemoryPool* pool) {
+  std::shared_ptr<ListConverter> ptr;
+
+  switch (type->id()) {
+#define CONVERTER_CASE(TYPE_ID, TYPE, VALUE_DECODER_TYPE)                             \
+  case TYPE_ID:                                                                       \
+    ptr.reset(new TypedListConverter<TYPE, VALUE_DECODER_TYPE>(type, options, pool)); \
+    break;
+#define REAL_CONVERTER_CASE(TYPE_ID, TYPE_CLASS, DECODER)                            \
+  case TYPE_ID:                                                                      \
+    ptr = MakeRealConverter<ListConverter, TypedListConverter, TYPE_CLASS, DECODER>( \
+        type, options, pool);                                                        \
+    break;
+    CONVERTER_CASE(Type::BOOL, BooleanType, BooleanValueDecoder)
+    CONVERTER_CASE(Type::INT8, Int8Type, NumericValueDecoder<Int8Type>)
+    CONVERTER_CASE(Type::INT16, Int16Type, NumericValueDecoder<Int16Type>)
+    CONVERTER_CASE(Type::INT32, Int32Type, NumericValueDecoder<Int32Type>)
+    CONVERTER_CASE(Type::INT64, Int64Type, NumericValueDecoder<Int64Type>)
+    /* No unsigned sql type, so hard to test, ignoring unsigned types  */
+    CONVERTER_CASE(Type::FLOAT, FloatType, NumericValueDecoder<FloatType>)
+    CONVERTER_CASE(Type::DOUBLE, DoubleType, NumericValueDecoder<DoubleType>)
+    REAL_CONVERTER_CASE(Type::DECIMAL, Decimal128Type, DecimalValueDecoder)
+    CONVERTER_CASE(Type::FIXED_SIZE_BINARY, FixedSizeBinaryType,
+                   FixedSizeBinaryValueDecoder)
+    CONVERTER_CASE(Type::BINARY, BinaryType, BinaryValueDecoder<false>)
+    CONVERTER_CASE(Type::LARGE_BINARY, LargeBinaryType, BinaryValueDecoder<false>)
+    // supporting only ISO-8601
+    CONVERTER_CASE(Type::TIMESTAMP, TimestampType, InlineISO8601ValueDecoder)
+
+    case Type::STRING:
+      if (options.check_utf8) {
+        ptr = std::make_shared<TypedListConverter<StringType, BinaryValueDecoder<true>>>(
+            type, options, pool);
+      } else {
+        ptr = std::make_shared<TypedListConverter<StringType, BinaryValueDecoder<false>>>(
+            type, options, pool);
+      }
+      break;
+
+    case Type::LARGE_STRING:
+      if (options.check_utf8) {
+        ptr = std::make_shared<
+            TypedListConverter<LargeStringType, BinaryValueDecoder<true>>>(type, options,
+                                                                           pool);
+      } else {
+        ptr = std::make_shared<
+            TypedListConverter<LargeStringType, BinaryValueDecoder<false>>>(type, options,
+                                                                            pool);
+      }
+      break;
+    default: {
+      return Status::NotImplemented("CSV list conversion to ", type->ToString(),
+                                    " is not supported");
+    }
+
+#undef CONVERTER_CASE
+  }
+  RETURN_NOT_OK(ptr->Initialize());
+  return ptr;
+}
+
 }  // namespace csv
 }  // namespace arrow
