diff --git a/cpp/CMakeLists.txt b/cpp/CMakeLists.txt
index eeda52091..e8749f00f 100644
--- a/cpp/CMakeLists.txt
+++ b/cpp/CMakeLists.txt
@@ -703,9 +703,10 @@ if(ARROW_WITH_SNAPPY)
 endif()
 
 if(ARROW_WITH_ZLIB)
-  list(APPEND ARROW_STATIC_LINK_LIBS ZLIB::ZLIB)
+  find_package(zlib-ng CONFIG REQUIRED)
+  list(APPEND ARROW_STATIC_LINK_LIBS zlib-ng::zlib-ng)
   if(ZLIB_SOURCE STREQUAL "SYSTEM")
-    list(APPEND ARROW_STATIC_INSTALL_INTERFACE_LIBS ZLIB::ZLIB)
+    list(APPEND ARROW_STATIC_INSTALL_INTERFACE_LIBS zlib-ng::zlib-ng)
   endif()
 endif()
 
diff --git a/cpp/src/arrow/util/compression_zlib.cc b/cpp/src/arrow/util/compression_zlib.cc
index 6dcc5153a..85f9c1b4e 100644
--- a/cpp/src/arrow/util/compression_zlib.cc
+++ b/cpp/src/arrow/util/compression_zlib.cc
@@ -23,8 +23,8 @@
 #include <limits>
 #include <memory>
 
-#include <zconf.h>
-#include <zlib.h>
+#include <zconf-ng.h>
+#include <zlib-ng.h>
 
 #include "arrow/result.h"
 #include "arrow/status.h"
@@ -93,7 +93,7 @@ class GZipDecompressor : public Decompressor {
 
   ~GZipDecompressor() override {
     if (initialized_) {
-      inflateEnd(&stream_);
+      zng_inflateEnd(&stream_);
     }
   }
 
@@ -104,7 +104,7 @@ class GZipDecompressor : public Decompressor {
 
     int ret;
     int window_bits = DecompressionWindowBitsForFormat(format_);
-    if ((ret = inflateInit2(&stream_, window_bits)) != Z_OK) {
+    if ((ret = zng_inflateInit2(&stream_, window_bits)) != Z_OK) {
       return ZlibError("zlib inflateInit failed: ");
     } else {
       initialized_ = true;
@@ -116,8 +116,8 @@ class GZipDecompressor : public Decompressor {
     DCHECK(initialized_);
     finished_ = false;
     int ret;
-    if ((ret = inflateReset(&stream_)) != Z_OK) {
-      return ZlibError("zlib inflateReset failed: ");
+    if ((ret = zng_inflateReset(&stream_)) != Z_OK) {
+      return ZlibError("zlib zng_inflateReset failed: ");
     } else {
       return Status::OK();
     }
@@ -133,7 +133,7 @@ class GZipDecompressor : public Decompressor {
     stream_.avail_out = static_cast<uInt>(std::min(output_len, input_limit));
     int ret;
 
-    ret = inflate(&stream_, Z_SYNC_FLUSH);
+    ret = zng_inflate(&stream_, Z_SYNC_FLUSH);
     if (ret == Z_DATA_ERROR || ret == Z_STREAM_ERROR || ret == Z_MEM_ERROR) {
       return ZlibError("zlib inflate failed: ");
     }
@@ -160,7 +160,7 @@ class GZipDecompressor : public Decompressor {
     return ZlibErrorPrefix(prefix_msg, stream_.msg);
   }
 
-  z_stream stream_;
+  zng_stream stream_;
   GZipFormat::type format_;
   bool initialized_;
   bool finished_;
@@ -176,7 +176,7 @@ class GZipCompressor : public Compressor {
 
   ~GZipCompressor() override {
     if (initialized_) {
-      deflateEnd(&stream_);
+      zng_deflateEnd(&stream_);
     }
   }
 
@@ -187,7 +187,7 @@ class GZipCompressor : public Compressor {
     int ret;
     // Initialize to run specified format
     int window_bits = CompressionWindowBitsForFormat(format);
-    if ((ret = deflateInit2(&stream_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, window_bits,
+    if ((ret = zng_deflateInit2(&stream_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, window_bits,
                             compression_level_, Z_DEFAULT_STRATEGY)) != Z_OK) {
       return ZlibError("zlib deflateInit failed: ");
     } else {
@@ -209,7 +209,7 @@ class GZipCompressor : public Compressor {
     stream_.avail_out = static_cast<uInt>(std::min(output_len, input_limit));
 
     int64_t ret = 0;
-    ret = deflate(&stream_, Z_NO_FLUSH);
+    ret = zng_deflate(&stream_, Z_NO_FLUSH);
     if (ret == Z_STREAM_ERROR) {
       return ZlibError("zlib compress failed: ");
     }
@@ -234,7 +234,7 @@ class GZipCompressor : public Compressor {
     stream_.avail_out = static_cast<uInt>(std::min(output_len, input_limit));
 
     int64_t ret = 0;
-    ret = deflate(&stream_, Z_SYNC_FLUSH);
+    ret = zng_deflate(&stream_, Z_SYNC_FLUSH);
     if (ret == Z_STREAM_ERROR) {
       return ZlibError("zlib flush failed: ");
     }
@@ -265,7 +265,7 @@ class GZipCompressor : public Compressor {
     stream_.avail_out = static_cast<uInt>(std::min(output_len, input_limit));
 
     int64_t ret = 0;
-    ret = deflate(&stream_, Z_FINISH);
+    ret = zng_deflate(&stream_, Z_FINISH);
     if (ret == Z_STREAM_ERROR) {
       return ZlibError("zlib flush failed: ");
     }
@@ -273,7 +273,7 @@ class GZipCompressor : public Compressor {
     if (ret == Z_STREAM_END) {
       // Flush complete, we can now end the stream
       initialized_ = false;
-      ret = deflateEnd(&stream_);
+      ret = zng_deflateEnd(&stream_);
       if (ret == Z_OK) {
         return EndResult{bytes_written, false};
       } else {
@@ -290,7 +290,7 @@ class GZipCompressor : public Compressor {
     return ZlibErrorPrefix(prefix_msg, stream_.msg);
   }
 
-  z_stream stream_;
+  zng_stream stream_;
   bool initialized_;
   int compression_level_;
 };
@@ -333,7 +333,7 @@ class GZipCodec : public Codec {
     int ret;
     // Initialize to run specified format
     int window_bits = CompressionWindowBitsForFormat(format_);
-    if ((ret = deflateInit2(&stream_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, window_bits,
+    if ((ret = zng_deflateInit2(&stream_, Z_DEFAULT_COMPRESSION, Z_DEFLATED, window_bits,
                             compression_level_, Z_DEFAULT_STRATEGY)) != Z_OK) {
       return ZlibErrorPrefix("zlib deflateInit failed: ", stream_.msg);
     }
@@ -343,7 +343,7 @@ class GZipCodec : public Codec {
 
   void EndCompressor() {
     if (compressor_initialized_) {
-      (void)deflateEnd(&stream_);
+      (void)zng_deflateEnd(&stream_);
     }
     compressor_initialized_ = false;
   }
@@ -355,7 +355,7 @@ class GZipCodec : public Codec {
 
     // Initialize to run either deflate or zlib/gzip format
     int window_bits = DecompressionWindowBitsForFormat(format_);
-    if ((ret = inflateInit2(&stream_, window_bits)) != Z_OK) {
+    if ((ret = zng_inflateInit2(&stream_, window_bits)) != Z_OK) {
       return ZlibErrorPrefix("zlib inflateInit failed: ", stream_.msg);
     }
     decompressor_initialized_ = true;
@@ -364,7 +364,7 @@ class GZipCodec : public Codec {
 
   void EndDecompressor() {
     if (decompressor_initialized_) {
-      (void)inflateEnd(&stream_);
+      (void)zng_inflateEnd(&stream_);
     }
     decompressor_initialized_ = false;
   }
@@ -383,8 +383,8 @@ class GZipCodec : public Codec {
     }
 
     // Reset the stream for this block
-    if (inflateReset(&stream_) != Z_OK) {
-      return ZlibErrorPrefix("zlib inflateReset failed: ", stream_.msg);
+    if (zng_inflateReset(&stream_) != Z_OK) {
+      return ZlibErrorPrefix("zlib zng_inflateReset failed: ", stream_.msg);
     }
 
     int ret = 0;
@@ -402,7 +402,7 @@ class GZipCodec : public Codec {
 
       // We know the output size.  In this case, we can use Z_FINISH
       // which is more efficient.
-      ret = inflate(&stream_, Z_FINISH);
+      ret = zng_inflate(&stream_, Z_FINISH);
       if (ret == Z_STREAM_END || ret != Z_OK) break;
 
       // Failure, buffer was too small
@@ -425,7 +425,7 @@ class GZipCodec : public Codec {
       Status s = InitCompressor();
       ARROW_CHECK_OK(s);
     }
-    int64_t max_len = deflateBound(&stream_, static_cast<uLong>(input_length));
+    int64_t max_len = zng_deflateBound(&stream_, static_cast<uLong>(input_length));
     // ARROW-3514: return a more pessimistic estimate to account for bugs
     // in old zlib versions.
     return max_len + 12;
@@ -442,7 +442,7 @@ class GZipCodec : public Codec {
     stream_.avail_out = static_cast<uInt>(output_buffer_len);
 
     int64_t ret = 0;
-    if ((ret = deflate(&stream_, Z_FINISH)) != Z_STREAM_END) {
+    if ((ret = zng_deflate(&stream_, Z_FINISH)) != Z_STREAM_END) {
       if (ret == Z_OK) {
         // Will return Z_OK (and stream.msg NOT set) if stream.avail_out is too
         // small
@@ -452,7 +452,7 @@ class GZipCodec : public Codec {
       return ZlibErrorPrefix("zlib deflate failed: ", stream_.msg);
     }
 
-    if (deflateReset(&stream_) != Z_OK) {
+    if (zng_deflateReset(&stream_) != Z_OK) {
       return ZlibErrorPrefix("zlib deflateReset failed: ", stream_.msg);
     }
 
@@ -478,7 +478,7 @@ class GZipCodec : public Codec {
  private:
   // zlib is stateful and the z_stream state variable must be initialized
   // before
-  z_stream stream_;
+  zng_stream stream_;
 
   // Realistically, this will always be GZIP, but we leave the option open to
   // configure
